ISSUE #1
Title: Refactor Collaboration Engine for Scalable State Management
Description: 
The current WebSocket implementation for real-time collaboration faces scalability challenges when multiple users edit basic text simultaneously. The objective is to refactor the collaboration service to use Y.js (CRDTs) for decentralized state management. This involves:
1. Implementing a custom WebSocket provider to handle Y.js updates.
2. Optimizing "awareness" states to efficiently broadcast cursor positions and user presence without flooding the network.
3. Designing a persistence layer that periodically flushes in-memory document states to the database to prevent data loss during server restarts, while maintaining the ability to merge offline edits gracefully.

ISSUE #2
Title: Implement AI-Powered Semantic Search & RAG Pipeline
Description:
Standard keyword search is insufficient for a knowledge base where querying by "concept" is more valuable than exact matches. We need to implement a Retrieval-Augmented Generation (RAG) pipeline.
1. Create a background worker that "chunks" and generates vector embeddings (using OpenAI or localized models) whenever a note is saved.
2. Store these embeddings in a vector-capable database (e.g., pgvector or Pinecone).
3. Build a "Ask AI" search interface that converts natural language queries into vectors, retrieves relevant context, and uses an LLM to synthesize an answer based strictly on the user's knowledge base.

ISSUE #3
Title: Design & Implement Hierarchical Role-Based Access Control (RBAC)
Description:
The current "Admin/Editor/Viewer" role system is flat and applies organization-wide. We need a granular, hierarchical permission system similar to Google Drive or Notion.
1. Implement a database schema that supports recursive permission inheritance (e.g., giving access to a folder grants access to all children).
2. Create middleware to efficiently resolve effective permissions at runtime without expensive recursive queries (possibly using Materialized Paths or Closure Tables).
3. Build a UI for managing groups and inviting external users with temporary, time-bound access links.

ISSUE #4
Title: Architect Offline-First Sync using IndexedDB & Service Workers
Description:
Users lose work if their internet connection drops. We need to transition the frontend to an "Offline-First" architecture.
1. Implement a local database (IndexedDB/RxDB) that acts as the single source of truth for the UI.
2. Create a background Service Worker that captures all mutations (creates, updates, deletes) in a "Sync Queue".
3. Develop a sophisticated reconciliation strategy that replays the queue when connectivity is restored, detecting and resolving conflicts (e.g., "Last Write Wins" or prompting the user) for changes made while offline.

ISSUE #5
Title: Implement Git-style Version History & Branching for Notes
Description:
Users need the ability to review past iterations of a document and potentially "branch" off a note for proposals.
1. Design a system to store delta updates (using Y.js updates or JSON patches) rather than full snapshots to save space.
2. Build a "Time Travel" UI that allows users to scrub through history, visualizing diffs (additions/deletion) between any two points in time.
3. Implement a "Fork/Merge" workflow where a user can create a divergent copy of a note and later propose merging changes back into the original document.

ISSUE #6
Title: Decouple Real-time WebSocket Server into Scalable Microservice
Description:
The WebSocket server is currently tightly coupled with the main Express API monolith. This prevents independent scaling of the real-time layer.
1. Extract the Socket.io logic into a standalone Node.js microservice.
2. Implement a Redis Adapter to allow Pub/Sub communication across multiple instances of the socket server (enabling horizontal scaling).
3. Secure the communication between the Main API (handling auth/REST) and the Socket Service using internal JWTs or gRPC to ensure that only authorized connections are upgraded to WebSockets.
